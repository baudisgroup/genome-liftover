import click
import sys
import pandas as pd
import subprocess
import logging
import os


##########################################################################
#
#                   Initialize globals
#
##########################################################################

log_dir = os.path.abspath('./logs')
chain_dir = os.path.abspath('./chains')
chainfile_18to19 = os.path.join(chain_dir, 'hg18ToHg19.over.chain')
chainfile_18to38 = os.path.join(chain_dir, 'hg18ToHg38.over.chain')
remapped_list = {}
file_list = []


################### loggers ###################

# check directory existance
os.makedirs(log_dir, exist_ok=True)
# system logger 
logger = logging.getLogger('liftover')
handler = logging.FileHandler(os.path.join(log_dir, 'liftover.log'), mode='w')
handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.setLevel(logging.INFO)
logger.addHandler(handler)

# prgress logger, records processed files, used for restore.
progress_logger = logging.getLogger('progress')
handler = logging.FileHandler(os.path.join(log_dir,'progress.log'), mode='w')
handler.setFormatter(logging.Formatter('%(message)s'))
progress_logger.setLevel(logging.INFO)
progress_logger.addHandler(handler)

# unmapped positions logger, records segments that's not properly lifted.
unmapped_logger = logging.getLogger('unmapped')
handler = logging.FileHandler(os.path.join(log_dir,'unmapped.log'), mode='w')
handler.setFormatter(logging.Formatter('%(message)s'))
unmapped_logger.setLevel(logging.INFO)
unmapped_logger.addHandler(handler)




# file = '/Volumes/arraymapMirror/arraymap/hg18/19197950/19197950_MB66_6332/segments.tab'
# ch = 'hg18ToHg19.over.chain'


# input_dir = '/Volumes/arraymapMirror/arraymap/hg18/GSE49'
# input_dir = '/Volumes/arraymapMirror/arraymap/hg18/GSE1755'
# output_dir = '/Users/bogao/DataFiles/hg19'
# segments_files = []
# probes_files = []


##########################################################################
#
#                   Utility functions
#
##########################################################################

# Map the unmapped positions to their nearest mappable positions
#
# Param:
# fin: path of the unmapped file generated by liftover
# chain: path of the chain file, should be same as used by liftover
# remap: the remapped_list
# steps: the searching range is 100(bps)/step * steps in both direction.
#
# Return:
# a list of lists with chro, new_pos, name 
# -1 in exception
#
# Note: unmappable positions will be returned with value 0
def solveUnmappables(fin, chain, remap, steps=10000):
    
    try:
        logger = logging.getLogger('liftover')
        
        # read in unmapped file
        df = pd.read_table(fin, sep='\t', comment='#', header=None, names=['chro','start','end','name'])
        df.loc[df.chro == 'chr23', 'chro'] = 'chrX'
        df.loc[df.chro == 'chr24', 'chro'] = 'chrY'
        # keep new coordinates
        positions = []
        # number of items
        num_pos = df.shape[0]
        counter = 0
        cmd = './liftOver'+ ' remap.bed ' + chain + ' remap_new.bed'+ ' remap.unmapped' + ' &>/dev/null'

        
        
        # For each unmapped postion,
        # if it is in the remapped_list, get new position from the list
        # otherwise, gradually search along both sides of the chromesome,
        # until a mappable position is found
        # If nothing is mappable in 20M base range, assume that pos is unmappable.
        for i in range(num_pos):

            chro = df.iloc[i,0]
            start = df.iloc[i,1]
            name = df.iloc[i,3]
            new_pos = 0
            new_chro = ''
            key = '{}_{}'.format(chro, start)

            # use buffered mapping is possible
            if key in remap:
                new_chro = remap[key][0]
                new_pos = remap[key][1]
                flag = remap[key][2]
                if flag == 'mapped':
                    counter += 1
                else:
                    logger.warning('Remapping failed: ' + str([chro, start, name]))
            # do a stepwise mapping
            else:
                with open('remap.bed', 'w') as f:
                    for i in range(1,steps):
                        print('{}\t{}\t{}\t{}'.format(chro, start+i*100, start+i*100+1, name), file=f)
                        print('{}\t{}\t{}\t{}'.format(chro, start-i*100, start-i*100+1, name), file=f)

                return_info = subprocess.run(cmd, shell=True)
                
                # check running result
                if return_info.returncode != 0 :
                    logger.warning('Remapping failed, cmd error: ' + str([chro, start, name]))
                elif os.path.getsize('remap_new.bed') == 0 :
                    logger.warning('Remapping failed: ' + str([chro, start, name]))
                    remap[key] = [new_chro, new_pos, 'unmapped']
                # use the first mapping result
                else:
                    with open('remap_new.bed', 'r') as f:
                        line = f.readline()
                        line = line.split('\t')
                        new_chro = line[0]
                        new_pos = int(line[1])
                        
                        remap[key] = [new_chro, new_pos, 'mapped']
                        counter += 1

            positions.append([new_chro, new_pos, name])
            
        logger.info('Remapped %i/%i unmapped positions.', counter, num_pos)
        return positions
    
    
    except Exception as e:
        logger.exception('Failed: %s', fin)
        return -1















# Convert the genome coordinates in segments.tab to the specified the edition
# according to the provided chain file.
#
# Params:
# fin: the path of the input file
# chain: the path of the chain file
# remap: the remapped_list
#
# Return: 
# 0 or -1
#
def convertSegments(fin, fo, chain, remap):
    
    logger = logging.getLogger('liftover')
    logger.info('Processing segment:\t%s', fin)
    
    try:

        #There are 2 different formats
        with open(fin,'r') as f:
            line = f.readline().split('\t')
            if len(line) == 6:
                col_names=['sample', 'chromosome', 'segStart', 'segStop', 'segMean','segProbes']
            elif len(line) == 7:
                col_names=['sample', 'chromosome', 'segStart', 'segStop', 'segType', 'segMean','segProbes']
            else:
                logger.error('Unknown format: %s', fin)
                raise

        df = pd.read_table(fin, sep='\t', header=0, names=col_names)

        #Generate new columns for processing
        df['chr'] = 'chr' + df['chromosome'].astype(str)
        df['name'] = df.index

        #Create a file of start coordinates
        df_starts = df.loc[:,['chr','segStart','segStop','name']]
        df_starts['segStop'] = df_starts.segStart + 1
        df_starts.to_csv('starts.bed', sep=' ', index=False, header=False)


        #Create a file of end coordinates
        df_ends = df.loc[:,['chr','segStart','segStop','name']]
        df_ends['segStart'] = df_ends.segStop - 1
        df_ends.to_csv('ends.bed', sep=' ', index=False, header=False)

    
    
        #Convert the start coordinates
        cmd = './liftOver' + ' starts.bed ' + chain + ' starts_new.bed' + ' starts.unmapped' + ' &>/dev/null'
        return_info = subprocess.run(cmd, shell=True)
        if return_info.returncode != 0 :
            logger.error('sh: %s', cmd)
            raise RuntimeError(cmd)
            
    
        #Read in the new start positions from a file
        starts_new = pd.read_table('starts_new.bed', sep='\t', names=df_starts.columns)
        del starts_new['segStop']

        #Remap unmapped start positions
        if os.path.getsize('starts.unmapped') >0:
            starts_remap = solveUnmappables('starts.unmapped', chain, remap)
            starts_remap = pd.DataFrame(starts_remap, columns=starts_new.columns)
            #Merge start positions
            starts_new = starts_new.append(starts_remap)
           
       
        #Convert the end coordinates
        cmd = './liftOver' + ' ends.bed ' + chain +  ' ends_new.bed' + ' ends.unmapped' + ' &>/dev/null'
        return_info = subprocess.run(cmd, shell=True)
        if return_info.returncode != 0 :
            logger.error('sh: %s', cmd)
            raise RuntimeError(cmd)
    
        #Read in the new end positions from a file
        ends_new = pd.read_table('ends_new.bed', sep='\t', names=df_ends.columns)
        del ends_new['segStart']
        #ends_new.rename(columns={'segStart':'segStop'}, inplace=True)


        #Remap unmapped end positions
        if os.path.getsize('ends.unmapped') >0:
            ends_remap = solveUnmappables('ends.unmapped', chain, remap)
            ends_remap = pd.DataFrame(ends_remap, columns=ends_new.columns)
            #Merge end positions
            ends_new = ends_new.append(ends_remap)
        
        

        #Merge new positions with original data 
        dd = pd.merge(starts_new,ends_new,how='inner', on=['name'], suffixes=['_s', '_e'])
        df_new = pd.merge(dd, df, how='left', on=['name'],suffixes=['_new','_old'])
        #df_new.drop(['chr', 'name', 'segStart_old', 'segStop_old'], axis=1, inplace=True)
        
        #Generate new columns for error checking
        df_new['chr_cmp'] = (df_new.chr_s == df_new.chr_e)
        df_new['pos_cmpRatio'] = (df_new.segStop_new - df_new.segStart_new) / (df_new.segStop_old - df_new.segStart_old)
        
        #Check bad liftovers
        df_mis = df_new[    ((df_new.segStart_new == 0) | (df_new.segStop_new == 0)) |
                            (df_new.chr_cmp == False) | 
                            ((df_new.pos_cmpRatio < 0.5) | (df_new.pos_cmpRatio > 2))]

        #Invoke unmapped logger
        unmapped_logger = logging.getLogger('unmapped')
        #logging unmapped positions
        for index, row in df_mis.iterrows():
            unmapped_logger.info('{}\t{}\t{}'.format(row['chr'],row['segStart_old'],row['segStop_old']))
                
        
        #Rename and rearrange columns back to the original format
        df_new = df_new[~df_new.name.isin(df_mis.name)]
        df_new.rename(columns={'segStart_new':'segStart', 'segStop_new':'segStop'}, inplace=True)
        df_new = df_new[col_names]
        os.makedirs(os.path.dirname(fo), exist_ok=True)
        df_new.to_csv(fo, sep='\t', index=False, float_format='%.4f') 
                
        logger.info('Finished\n')
        progress_logger = logging.getLogger('progress')
        progress_logger.info(fin)
        return 0
    
    except Exception as e:
        logger.exception('Failed: %s', fin)
        return -1
        
    













# Convert the genome coordinates in CNprobes.tab to the specified the edition
# according to the provided chain file.
#
# Params:
# fin: the path of the input file
# chain: the path of the chain file
# remap: the remapped_list
#
# Return: 
# 0 or -1
#
def convertProbes(fin, fo, chain, remap):
    
    logger = logging.getLogger('liftover')
    logger.info('Processing probe:\t%s', fin)
    
    try:
        col_names=['probeID', 'chro', 'pos', 'value']
        with open(fin, 'r') as f:
            line = f.readline().split('\t')
            if len(line) != 4:
                logger.error('Unknown format: %s', fin)
                raise

        df = pd.read_table(fin, sep='\t', header=0, names=col_names )
        
        #Generate new columns for processing
        df['chr'] = 'chr' + df['chro'].astype(str)
        df['name'] = df.index

        #Create a file of probe coordinates
        df_probes = df.loc[:,['chr','pos']]
        df_probes['pos1'] = df_probes.pos + 1
        df_probes['name'] = df_probes.index
        df_probes.to_csv('probes.bed', sep=' ', index=False, header=False)

    
        #Convert the probe coordinates
        cmd = './liftOver' + ' probes.bed ' + chain + ' probes_new.bed' + ' probes.unmapped' + ' &>/dev/null'
        return_info = subprocess.run(cmd, shell=True)
        if return_info.returncode != 0 :
            logger.error('sh: %s', cmd)
            raise RuntimeError(cmd)
            
    
        #Read in the new probe positions from a file
        probes_new = pd.read_table('probes_new.bed', sep='\t', names=df_probes.columns)
        del probes_new['pos1']


        #Remap the unmapped
        if os.path.getsize('probes.unmapped') >0:
            probes_remap = solveUnmappables('probes.unmapped', chain, remap)
            probes_remap = pd.DataFrame(probes_remap, columns=probes_new.columns)
            #Merage new positions
            probes_new = probes_new.append(probes_remap)
        
        #Merge and rearrange the coloumns to the original format
        df_new = pd.merge(probes_new, df, how='left', on=['name'],suffixes=['_new','_old'])
        
        #Check if new and old positions are on the chromosome
        df_new['chr_cmp'] = (df_new.chr_new == df_new.chr_old)        
        #Check if the new position is unmappable
        #Merge all unmapped positions
        df_mis = df_new[ (df_new.chr_cmp == False) | (df_new.pos_new == 0)]

        #Invoke unmapped logger
        unmapped_logger = logging.getLogger('unmapped')
        #logging unmapped positions
        for index, row in df_mis.iterrows():
            unmapped_logger.info('%s\t%i', row['chr_old'],row['pos_old'])
        
        
        df_new = df_new[~df_new.name.isin(df_mis.name)]
        df_new.rename(columns={'pos_new':'pos'}, inplace=True)
        df_new = df_new[col_names]
        
        os.makedirs(os.path.dirname(fo), exist_ok=True)
        df_new.to_csv(fo, sep='\t', index=False, float_format='%.4f') 
        
        logger.info('Finished\n')
        progress_logger = logging.getLogger('progress')
        progress_logger.info(fin)
        return 0
    
    except Exception as e:
        logger.exception('Failed: %s', fin)
        return -1
        






##########################################################################
#
#                   Command line interface
#
##########################################################################

@click.command()
@click.option('-i', '--input_dir', help='The direcotry to start processing.')
@click.option('-o', '--output_dir', help='The direcotry to write new files.')
@click.option('-g', '--genome_editions', type=click.Choice(['18to19', '18to38']), help='The genome editions of liftover.')
@click.option('-c', '--clean', is_flag=True, help='Clean up log files.')
@click.option('-t', '--test_mode', type=click.IntRange(1,1000), help='Only process a limited number of files.')
@click.option('-f', '--file_indexing', is_flag=True, help='Only generate the indexing file.')
def cli(input_dir, output_dir, genome_editions, clean, test_mode, file_indexing):



    test_counter = 0

    # Clean the log files
    if clean:
        for f in os.listdir(log_dir):
            path = os.path.join(log_dir, f)
            if os.path.isfile(path):
                os.remove(path)
        sys.exit('Log files cleaned up.')

    # Validate input_dir
    if input_dir:
        if os.path.isdir(input_dir) == False:
            sys.exit('Error: input direcotry does not exist.')
    else:
        sys.exit('Error: input_dir, out_dir and genome_editions are required. Check --help for more information.')




    # Validate output_dir
    if output_dir:
        if os.path.isdir(output_dir) == False:
            sys.exit('Error: output direcotry does not exist.')
    else:
        sys.exit('Error: input_dir, out_dir and genome_editions are required. Check --help for more information.')

    # Validate genome_editions
    if not genome_editions:
        sys.exit('Error: input_dir, out_dir and genome_editions are required. Check --help for more information.')
    if genome_editions == '18to19':
        chainfile = chainfile_18to19
    elif genome_editions == '18to38':
        chainfile = chainfile_18to38


    #########   Indexing all the files to be processed   ############

    #Recover the file list, if fileList.log exists.
    if os.path.isfile(os.path.join(log_dir, 'fileList.log')):
        print('Index file detected, recovering...')
        with open(os.path.join(log_dir, 'fileList.log'), 'r') as fin:
            for line in fin:
                file_list.append(line.strip())

                # test mode
                if test_mode:
                    test_counter += 1
                    if test_counter > test_mode:
                        break

    #Traverse directories to index all segments.tab and CNprobes.tab files.
    else:
        print('Indexing files to process, this may take some time.')
        with click.progressbar(os.walk(input_dir), label='Be patient: ', fill_char=click.style('*', fg='red')) as bar:

            # File traverse
            for root, subdirs, files in bar:
                for f in files:
                    if (f == 'segments.tab') or (f == 'CNprobes.tab'):
                        path = os.path.join(root,f)
                        file_list.append(path)
                        # test mode
                if test_mode:
                    test_counter += 1
                    if test_counter > test_mode:
                        break

            # Save the file list to disk
            with open(os.path.join(log_dir, 'fileList.log'), 'w') as fo:
                for line in file_list:
                    print(line,file=fo)

            # Terminate for file_indexing mode
            if file_indexing:
                sys.exit('Indexing file created.')



    #########   Liftover   ############

    with click.progressbar(file_list, label='Lifting: ', fill_char=click.style('*', fg='green')) as bar:
        for f in bar:
            #generate output path
            rel_path = os.path.relpath(os.path.dirname(f), input_dir)
            out_path = os.path.join(output_dir, rel_path, os.path.basename(f))

            if os.path.basename(f) == 'segments.tab':
                code = convertSegments(f, out_path, chainfile,remapped_list)
            elif os.path.basename(f) == 'CNprobes.tab':
                code = convertProbes(f, out_path, chainfile, remapped_list)
            else:
                print('Unknown file type: ' + f)
                logger.error('Unknown file type: ' + f)
        


    # Remove temp files.
    subprocess.run('rm *.bed *.unmapped  &>/dev/null', shell=True)

##########################################################################
#
#                   Main
#
##########################################################################
if __name__ == '__main__':
    cli()
